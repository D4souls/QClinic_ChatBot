import mysql from 'mysql2'
import dotenv from 'dotenv'
import { callAssistant } from './ollama/chatbot.js';
import { initGPT } from './gpt/init-chatGPT.js';

dotenv.config();

const pool = mysql.createPool({
    host: process.env.MYSQL_HOST,
    port: process.env.MYSQL_PORT,
    user: process.env.MYSQL_USER,
    password: process.env.MYSQL_PASSWORD,
    database: process.env.MYSQL_DATABASE
}) .promise();

export function formatBotResponse(response){
    const getBotResponse = response.data.slice(0,1);
    const formatRes = getBotResponse[0].content[0].text.value;

    return formatRes;
}

export async function botQuery(query) {

    console.log(`Promt generated by IA: ${query}`);

    try {
        
        const selectRegEx = /^SELECT/i;
        const insertRegEx = /^INSERT/i;
        const updateRegEx = /^UPDATE/i;
        const deleteRegEx = /^DELETE/i;
        
        if (selectRegEx.test(query)) {
            
            const res = await selectQuery(query);
            return res;

        } else if (insertRegEx.test(query)) {

            const res = await insertQuery(query);
            return res;

        } else if (updateRegEx.test(query)) {

            const res = await updateQuery(query);
            return res;

        } else if (deleteRegEx.test(query)) {

            const res = await deleteQuery(query);
            return res;

        } else {
            return {success: true, data: query};
        }

    } catch (error) {
        return {success: false, error: error.message}
    }
}

async function selectQuery(query){
    try {
        
        const [rows] = await pool.query(query);

        return rows.length > 0 ? {success: true, data: rows, type: 'SELECT'} : {success: true, data: "No data found", type: 'SELECT'}

    } catch (error) {
        return {success: false, error: error.message, type: 'ERROR'}
    }
}

async function insertQuery(query){
    try {
        
        const [rows] = await pool.query(query);

        if (process.env.AI_LOCAL == 'false'){

            if (rows.affectedRows > 0){

                // Return result to ChatGPT again to create SELECT QUERY
                const assistant = await initGPT(`¿Qué consulta SQL necesito para obtener los datos que acabo de solicitar? Solamente retorna el comando SQL necesario.`)
    
                if (assistant) {
                    const getNewItem = await botQuery(assistant);
    
                    return getNewItem;
                }
            }
    
            return {success: false, error: "Error insert"}

        } else {
            return rows.affectedRows > 0 ? {success: true, type: 'INSERT'} : {success: false, type: 'INSERT'};
        }



    } catch (error) {
        return {success: false, error: error.message, type: 'INSERT'}
    }
}

async function deleteQuery(query){
    try {
        
        const [rows] = await pool.query(query);

        if (process.env.AI_LOCAL == 'false'){

            if (rows.affectedRows > 0){

                // Return result to ChatGPT again to create SELECT QUERY
                const assistant = await initGPT(`Una vez realizada la acción necesito retornar un mensaje al usuario indicando si la consulta ha ido bien o no. Filas afectadas: ${rows.affectedRows}`)
    
                if (assistant) {
                    const getNewItem = await botQuery(assistant);
    
                    return getNewItem;
                }
            }
    
            return {success: false, error: "Error delete"}

        } else {
            return rows.affectedRows > 0 ? {success: true, type: 'DELETE'} : {success: false, type: 'DELETE'};
        }



    } catch (error) {
        return {success: false, error: error.message, type: 'DELETE'}
    }
}

async function updateQuery(query){
    try {
        
        const [rows] = await pool.query(query);

        if (process.env.AI_LOCAL == 'false'){

            if (rows.affectedRows > 0){

                // Return result to ChatGPT again to create SELECT QUERY
                const assistant = await initGPT(`Una vez realizada la acción necesito retornar un mensaje al usuario indicando si la consulta ha ido bien o no. Filas afectadas: ${rows.affectedRows}`)
    
                if (assistant) {
                    const getNewItem = await botQuery(assistant);
    
                    return getNewItem;
                }
            }
    
            return {success: false, error: "Error update"}

        } else {
            return rows.affectedRows > 0 ? {success: true, type: 'UPDATE'} : {success: false, type: 'UPDATE'};
        }


    } catch (error) {
        return {success: false, error: error.message, type: 'UPDATE'};
    }
}