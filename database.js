import mysql from 'mysql2'
import dotenv from 'dotenv'
import { callAssistant } from './chatBot/chatbot.js';

dotenv.config();

const pool = mysql.createPool({
    host: process.env.MYSQL_HOST,
    port: process.env.MYSQL_PORT,
    user: process.env.MYSQL_USER,
    password: process.env.MYSQL_PASSWORD,
    database: process.env.MYSQL_DATABASE
}) .promise();

export async function testQuery() {
    
    try {
        const [rows] = await pool.query("SELECT * FROM berries");

        if (rows.length > 0) return {success: true, data: rows}

        return {success: false, error: "There are any berries"}
    } catch (error) {
        return {success: false, error: error.message}
    }

}

export function formatBotResponse(response){
    const getBotResponse = response.data.slice(0,1);
    const formatRes = getBotResponse[0].content[0].text.value;

    return formatRes;
}

export async function botQuery(query) {

    console.log(`Promt generated by IA: ${query}`);

    try {
        
        const selectRegEx = /^SELECT/i;
        const insertRegEx = /^INSERT/i;
        const updateRegEx = /^UPDATE/i;
        const deleteRegEx = /^DELETE/i;
        
        if (selectRegEx.test(query)) {
            
            const res = await selectQuery(query);
            return res;

        } else if (insertRegEx.test(query)) {

            const res = await insertQuery(query);
            return res;

        } else if (updateRegEx.test(query)) {

            const res = await updateQuery(query);
            return res;

        } else if (deleteRegEx.test(query)) {

            const res = await deleteQuery(query);
            return res;

        } else {
            return {success: true, data: query};
        }

    } catch (error) {
        return {success: false, error: error.message}
    }
}

async function selectQuery(query){
    try {
        
        const [rows] = await pool.query(query);

        return rows.length > 0 ? {success: true, data: rows} : {success: true, data: "No data found"}

    } catch (error) {
        return {success: false, error: error.message}
    }
}

async function insertQuery(query){
    try {
        
        const [rows] = await pool.query(query);

        if (rows.affectedRows > 0){

            // Return result to ChatGPT again to create SELECT QUERY
            const assistant = await callAssistant(`¿Qué consulta SQL necesito para obtener los datos que acabo de solicitar? Solamente retorna el comando SQL necesario.`)

            if (assistant) {
                const getNewItem = await botQuery(formatBotResponse(assistant));

                return getNewItem;
            }
        }

        return {success: false, data: "Error creating"}

    } catch (error) {
        return {success: false, error: error.message}
    }
}

async function deleteQuery(query){
    try {
        
        const [rows] = await pool.query(query);

        if (rows.affectedRows > 0) {
            // Return result to ChatGPT again to create a info message
            const assistant = await callAssistant(`Una vez realizada la acción necesito retornar un mensaje al usuario indicando si la consulta ha ido bien o no: ${rows.affectedRows}`);
    
            if (assistant) {
                const infoMessage = await botQuery(formatBotResponse(assistant));
                return infoMessage;
            }
        } else {
            return {success: false, data: `Error deleting query`}
        }


    } catch (error) {
        return {success: false, error: error.message}
    }
}

async function updateQuery(query){
    try {
        
        const [rows] = await pool.query(query);

        if (rows.affectedRows > 0) {
            // Return result to ChatGPT again to create a info message
            const assistant = await callAssistant(`Una vez realizada la acción necesito retornar un mensaje al usuario indicando si la consulta ha ido bien o no: ${rows.affectedRows}`);
    
            if (assistant) {
                const infoMessage = await botQuery(formatBotResponse(assistant));
                return infoMessage;
            }
        } else {
            return {success: false, data: `Error deleting query`}
        }

    } catch (error) {
        return {success: false, error: error.message}
    }
}